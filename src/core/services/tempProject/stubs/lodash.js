module.exports = `// Type definitions for Lodash

// Array functions
export function chunk<T>(array: T[], size?: number): T[][];
export function compact<T>(array: (T | null | undefined | false | "" | 0)[]): T[];
export function concat<T>(...arrays: (T | T[])[]): T[];
export function difference<T>(array: T[], ...values: T[][]): T[];
export function drop<T>(array: T[], n?: number): T[];
export function dropRight<T>(array: T[], n?: number): T[];
export function fill<T>(array: any[], value: T, start?: number, end?: number): T[];
export function flatten<T>(array: T[][] | T[]): T[];
export function flattenDeep<T>(array: any[]): T[];
export function head<T>(array: T[]): T | undefined;
export function indexOf<T>(array: T[], value: T, fromIndex?: number): number;
export function initial<T>(array: T[]): T[];
export function intersection<T>(...arrays: T[][]): T[];
export function join<T>(array: T[], separator?: string): string;
export function last<T>(array: T[]): T | undefined;
export function pull<T>(array: T[], ...values: T[]): T[];
export function remove<T>(array: T[], predicate: (value: T) => boolean): T[];
export function reverse<T>(array: T[]): T[];
export function slice<T>(array: T[], start?: number, end?: number): T[];
export function tail<T>(array: T[]): T[];
export function take<T>(array: T[], n?: number): T[];
export function union<T>(...arrays: T[][]): T[];
export function uniq<T>(array: T[]): T[];
export function uniqBy<T>(array: T[], iteratee: string | ((value: T) => any)): T[];
export function without<T>(array: T[], ...values: T[]): T[];
export function zip<T>(...arrays: T[][]): T[][];

// Collection functions
export function countBy<T>(collection: T[], iteratee?: string | ((value: T) => any)): { [key: string]: number };
export function every<T>(collection: T[], predicate?: (value: T) => boolean): boolean;
export function filter<T>(collection: T[], predicate: (value: T) => boolean): T[];
export function find<T>(collection: T[], predicate: (value: T) => boolean): T | undefined;
export function findLast<T>(collection: T[], predicate: (value: T) => boolean): T | undefined;
export function forEach<T>(collection: T[], iteratee: (value: T, index: number) => void): T[];
export function groupBy<T>(collection: T[], iteratee: string | ((value: T) => any)): { [key: string]: T[] };
export function includes<T>(collection: T[], value: T, fromIndex?: number): boolean;
export function keyBy<T>(collection: T[], iteratee: string | ((value: T) => any)): { [key: string]: T };
export function map<T, U>(collection: T[], iteratee: (value: T, index: number) => U): U[];
export function orderBy<T>(collection: T[], iteratees: string[], orders?: string[]): T[];
export function partition<T>(collection: T[], predicate: (value: T) => boolean): [T[], T[]];
export function reduce<T, U>(collection: T[], iteratee: (acc: U, value: T, index: number) => U, accumulator: U): U;
export function reject<T>(collection: T[], predicate: (value: T) => boolean): T[];
export function sample<T>(collection: T[]): T | undefined;
export function sampleSize<T>(collection: T[], n?: number): T[];
export function shuffle<T>(collection: T[]): T[];
export function size<T>(collection: T[] | object): number;
export function some<T>(collection: T[], predicate?: (value: T) => boolean): boolean;
export function sortBy<T>(collection: T[], iteratees: string | string[] | ((value: T) => any)[]): T[];

// Object functions
export function assign<T>(object: T, ...sources: any[]): T;
export function assignIn<T>(object: T, ...sources: any[]): T;
export function clone<T>(value: T): T;
export function cloneDeep<T>(value: T): T;
export function defaults<T>(object: T, ...sources: any[]): T;
export function defaultsDeep<T>(object: T, ...sources: any[]): T;
export function findKey<T>(object: T, predicate: (value: any, key: string) => boolean): string | undefined;
export function forIn<T>(object: T, iteratee: (value: any, key: string) => void): T;
export function forOwn<T>(object: T, iteratee: (value: any, key: string) => void): T;
export function get<T>(object: any, path: string | string[], defaultValue?: T): T;
export function has(object: any, path: string | string[]): boolean;
export function invert<T>(object: T): any;
export function keys<T>(object: T): string[];
export function mapKeys<T>(object: T, iteratee: (value: any, key: string) => string): any;
export function mapValues<T>(object: T, iteratee: (value: any, key: string) => any): any;
export function merge<T>(object: T, ...sources: any[]): T;
export function omit<T, K extends keyof T>(object: T, ...paths: (K | string)[]): Omit<T, K>;
export function omitBy<T>(object: T, predicate: (value: any, key: string) => boolean): Partial<T>;
export function pick<T, K extends keyof T>(object: T, ...paths: (K | string)[]): Pick<T, K>;
export function pickBy<T>(object: T, predicate: (value: any, key: string) => boolean): Partial<T>;
export function result<T>(object: any, path: string | string[], defaultValue?: T): T;
export function set<T>(object: T, path: string | string[], value: any): T;
export function toPairs<T>(object: T): [string, any][];
export function transform<T, U>(object: T, iteratee: (acc: U, value: any, key: string) => void, accumulator?: U): U;
export function unset<T>(object: T, path: string | string[]): boolean;
export function update<T>(object: T, path: string | string[], updater: (value: any) => any): T;
export function values<T>(object: T): any[];

// String functions
export function camelCase(string?: string): string;
export function capitalize(string?: string): string;
export function deburr(string?: string): string;
export function endsWith(string?: string, target?: string, position?: number): boolean;
export function escape(string?: string): string;
export function escapeRegExp(string?: string): string;
export function kebabCase(string?: string): string;
export function lowerCase(string?: string): string;
export function lowerFirst(string?: string): string;
export function pad(string?: string, length?: number, chars?: string): string;
export function padEnd(string?: string, length?: number, chars?: string): string;
export function padStart(string?: string, length?: number, chars?: string): string;
export function parseInt(string: string, radix?: number): number;
export function repeat(string?: string, n?: number): string;
export function replace(string?: string, pattern: string | RegExp, replacement: string): string;
export function snakeCase(string?: string): string;
export function split(string?: string, separator?: string | RegExp, limit?: number): string[];
export function startCase(string?: string): string;
export function startsWith(string?: string, target?: string, position?: number): boolean;
export function template(string?: string, options?: any): (data?: any) => string;
export function toLower(string?: string): string;
export function toUpper(string?: string): string;
export function trim(string?: string, chars?: string): string;
export function trimEnd(string?: string, chars?: string): string;
export function trimStart(string?: string, chars?: string): string;
export function truncate(string?: string, options?: { length?: number; omission?: string; separator?: string | RegExp }): string;
export function unescape(string?: string): string;
export function upperCase(string?: string): string;
export function upperFirst(string?: string): string;
export function words(string?: string, pattern?: string | RegExp): string[];

// Function functions
export function after(n: number, func: (...args: any[]) => any): (...args: any[]) => any;
export function ary(func: (...args: any[]) => any, n?: number): (...args: any[]) => any;
export function before(n: number, func: (...args: any[]) => any): (...args: any[]) => any;
export function bind(func: (...args: any[]) => any, thisArg: any, ...partials: any[]): (...args: any[]) => any;
export function curry<T extends (...args: any[]) => any>(func: T): T;
export function debounce<T extends (...args: any[]) => any>(func: T, wait?: number, options?: { leading?: boolean; maxWait?: number; trailing?: boolean }): T & { cancel(): void; flush(): any };
export function defer(func: (...args: any[]) => any, ...args: any[]): number;
export function delay(func: (...args: any[]) => any, wait: number, ...args: any[]): number;
export function flip<T extends (...args: any[]) => any>(func: T): T;
export function memoize<T extends (...args: any[]) => any>(func: T, resolver?: (...args: any[]) => any): T & { cache: Map<any, any> };
export function negate(predicate: (...args: any[]) => boolean): (...args: any[]) => boolean;
export function once<T extends (...args: any[]) => any>(func: T): T;
export function overArgs(func: (...args: any[]) => any, ...transforms: ((...args: any[]) => any)[]): (...args: any[]) => any;
export function partial<T extends (...args: any[]) => any>(func: T, ...partials: any[]): T;
export function partialRight<T extends (...args: any[]) => any>(func: T, ...partials: any[]): T;
export function rearg(func: (...args: any[]) => any, ...indexes: number[]): (...args: any[]) => any;
export function rest<T extends (...args: any[]) => any>(func: T, start?: number): T;
export function spread<T extends (args: any[]) => any>(func: T, start?: number): (...args: any[]) => any;
export function throttle<T extends (...args: any[]) => any>(func: T, wait?: number, options?: { leading?: boolean; trailing?: boolean }): T & { cancel(): void; flush(): any };
export function unary<T extends (...args: any[]) => any>(func: T): T;
export function wrap(value: any, wrapper: (value: any, ...args: any[]) => any): (...args: any[]) => any;

// Utility functions
export function attempt<T>(func: (...args: any[]) => T, ...args: any[]): T | Error;
export function bindAll<T>(object: T, ...methodNames: string[]): T;
export function cond(pairs: [(...args: any[]) => boolean, (...args: any[]) => any][]): (...args: any[]) => any;
export function constant<T>(value: T): () => T;
export function defaultTo<T>(value: any, defaultValue: T): T;
export function flow<T extends (...args: any[]) => any>(...funcs: ((...args: any[]) => any)[]): T;
export function flowRight<T extends (...args: any[]) => any>(...funcs: ((...args: any[]) => any)[]): T;
export function identity<T>(value: T): T;
export function iteratee(func?: any): (...args: any[]) => any;
export function matches<T>(source: Partial<T>): (object: T) => boolean;
export function matchesProperty<T>(path: string | string[], srcValue: any): (object: T) => boolean;
export function method(path: string | string[], ...args: any[]): (object: any) => any;
export function methodOf(object: any, ...args: any[]): (path: string | string[]) => any;
export function mixin(object?: any, source?: any, options?: { chain?: boolean }): any;
export function noConflict(): typeof _;
export function noop(): void;
export function nthArg(n?: number): (...args: any[]) => any;
export function over<T>(...iteratees: ((...args: any[]) => any)[]): (...args: any[]) => T[];
export function overEvery(...predicates: ((...args: any[]) => boolean)[]): (...args: any[]) => boolean;
export function overSome(...predicates: ((...args: any[]) => boolean)[]): (...args: any[]) => boolean;
export function property<T>(path: string | string[]): (object: any) => T;
export function propertyOf<T>(object: any): (path: string | string[]) => T;
export function range(start: number, end?: number, step?: number): number[];
export function rangeRight(start: number, end?: number, step?: number): number[];
export function stubArray<T>(): T[];
export function stubFalse(): false;
export function stubObject(): {};
export function stubString(): "";
export function stubTrue(): true;
export function times<T>(n: number, iteratee: (index: number) => T): T[];
export function toPath(value: any): string[];
export function uniqueId(prefix?: string): string;

// Type checking functions
export function isArguments(value: any): value is IArguments;
export function isArray(value: any): value is any[];
export function isArrayBuffer(value: any): value is ArrayBuffer;
export function isArrayLike(value: any): value is ArrayLike<any>;
export function isArrayLikeObject(value: any): value is ArrayLike<object>;
export function isBoolean(value: any): value is boolean;
export function isBuffer(value: any): boolean;
export function isDate(value: any): value is Date;
export function isElement(value: any): value is Element;
export function isEmpty(value: any): boolean;
export function isEqual(value: any, other: any): boolean;
export function isEqualWith(value: any, other: any, customizer?: (value: any, other: any, key?: string, object?: any, otherObject?: any) => boolean | undefined): boolean;
export function isError(value: any): value is Error;
export function isFinite(value: any): boolean;
export function isFunction(value: any): value is Function;
export function isInteger(value: any): value is number;
export function isLength(value: any): boolean;
export function isMap(value: any): value is Map<any, any>;
export function isMatch(object: any, source: any): boolean;
export function isMatchWith(object: any, source: any, customizer?: (value: any, srcValue: any, key?: string, object?: any, source?: any) => boolean | undefined): boolean;
export function isNaN(value: any): boolean;
export function isNative(value: any): boolean;
export function isNil(value: any): value is null | undefined;
export function isNull(value: any): value is null;
export function isNumber(value: any): value is number;
export function isObject(value: any): value is object;
export function isObjectLike(value: any): boolean;
export function isPlainObject(value: any): boolean;
export function isRegExp(value: any): value is RegExp;
export function isSafeInteger(value: any): value is number;
export function isSet(value: any): value is Set<any>;
export function isString(value: any): value is string;
export function isSymbol(value: any): value is symbol;
export function isTypedArray(value: any): boolean;
export function isUndefined(value: any): value is undefined;
export function isWeakMap(value: any): value is WeakMap<any, any>;
export function isWeakSet(value: any): value is WeakSet<any>;

// Math functions
export function add(augend: number, addend: number): number;
export function ceil(n: number, precision?: number): number;
export function divide(dividend: number, divisor: number): number;
export function floor(n: number, precision?: number): number;
export function max<T>(array: T[]): T | undefined;
export function maxBy<T>(array: T[], iteratee: string | ((value: T) => any)): T | undefined;
export function mean(array: number[]): number;
export function meanBy<T>(array: T[], iteratee: string | ((value: T) => number)): number;
export function min<T>(array: T[]): T | undefined;
export function minBy<T>(array: T[], iteratee: string | ((value: T) => any)): T | undefined;
export function multiply(multiplier: number, multiplicand: number): number;
export function round(n: number, precision?: number): number;
export function subtract(minuend: number, subtrahend: number): number;
export function sum(array: number[]): number;
export function sumBy<T>(array: T[], iteratee: string | ((value: T) => number)): number;

// Number functions
export function clamp(number: number, lower: number, upper: number): number;
export function inRange(number: number, start: number, end?: number): boolean;
export function random(lower?: number, upper?: number, floating?: boolean): number;

// Default export
declare const _: {
  chunk: typeof chunk;
  compact: typeof compact;
  concat: typeof concat;
  difference: typeof difference;
  flatten: typeof flatten;
  uniq: typeof uniq;
  groupBy: typeof groupBy;
  keyBy: typeof keyBy;
  orderBy: typeof orderBy;
  sortBy: typeof sortBy;
  clone: typeof clone;
  cloneDeep: typeof cloneDeep;
  merge: typeof merge;
  assign: typeof assign;
  defaults: typeof defaults;
  get: typeof get;
  set: typeof set;
  has: typeof has;
  pick: typeof pick;
  omit: typeof omit;
  keys: typeof keys;
  values: typeof values;
  toPairs: typeof toPairs;
  camelCase: typeof camelCase;
  kebabCase: typeof kebabCase;
  snakeCase: typeof snakeCase;
  startCase: typeof startCase;
  lowerCase: typeof lowerCase;
  upperCase: typeof upperCase;
  capitalize: typeof capitalize;
  trim: typeof trim;
  debounce: typeof debounce;
  throttle: typeof throttle;
  delay: typeof delay;
  memoize: typeof memoize;
  once: typeof once;
  isEqual: typeof isEqual;
  isEmpty: typeof isEmpty;
  isArray: typeof isArray;
  isObject: typeof isObject;
  isString: typeof isString;
  isNumber: typeof isNumber;
  isBoolean: typeof isBoolean;
  isFunction: typeof isFunction;
  isUndefined: typeof isUndefined;
  isNull: typeof isNull;
  map: typeof map;
  filter: typeof filter;
  reduce: typeof reduce;
  forEach: typeof forEach;
  find: typeof find;
  some: typeof some;
  every: typeof every;
  includes: typeof includes;
  size: typeof size;
  max: typeof max;
  min: typeof min;
  sum: typeof sum;
  mean: typeof mean;
  round: typeof round;
  floor: typeof floor;
  ceil: typeof ceil;
  clamp: typeof clamp;
  random: typeof random;
  range: typeof range;
  times: typeof times;
  uniqueId: typeof uniqueId;
  noop: typeof noop;
  identity: typeof identity;
  constant: typeof constant;
  template: typeof template;
};

export default _;`;
